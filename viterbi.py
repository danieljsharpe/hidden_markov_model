'''
Viterbi algorithm to find the most likely sequence of hidden states (Viterbi path)
that results in a sequence of observed events for a given hidden Markov model (HMM)
'''

import numpy as np


class Viterbi(object):

    def __init__(self, O, S, Pi, A, B, T, Y=None, randseed=19):
        np.random.seed(randseed)
        self.O, self.S = O, S
        self.Pi = Pi
        self.A, self.B = A, B
        self.T = T
        self.N, self.K = len(O), len(S)
        self.Z1 = np.zeros((self.K,T),dtype=float)
        self.Z2 = np.zeros((self.K,T),dtype=int)
        if Y is None: # observations not provided, randomly generate some
            self.Y = [np.random.choice(self.O) for t in range(self.T)]
        else:
            self.Y = Y
        assert self.T == len(self.Y)
        print "\nObservations:\n", self.Y

    def get_viterbi_path(self):
        Z, X = [0]*self.T, [0]*self.T
        # initial observation
        y_j_idx = self.O.index(self.Y[0]) #first observation
        for i in range(self.K):
            self.Z1[i,0] = self.Pi[i]*self.B[i,y_j_idx]#0]
        # all other observations
        for j in range(1,self.T):
            for i in range(self.K):
                y_j_idx = self.O.index(self.Y[j])
                max_tr_prob_idx, max_tr_prob = max((enumerate(self.Z1[k,j-1]*self.A[k,i]*self.B[i,y_j_idx] \
                        for (k, s) in enumerate(S))), key=lambda p: p[1])
                self.Z1[i,j] = max_tr_prob
                self.Z2[i,j] = max_tr_prob_idx
        Z[-1] = list(self.Z1[:,self.T-1]).index(max(self.Z1[:,self.T-1])) # z_T
        prob = max(self.Z1[:,self.T-1])
        X[-1] = self.S[Z[-1]] # x_T
        # backtracking
        for i in range(self.T-1,0,-1):
            Z[i-1] = self.Z2[Z[i],i]
            X[i-1] = self.S[Z[i-1]]
        return X, prob # X is Viterbi path {x_i}, a sequence of T states given a sequence of T observations

if __name__ == "__main__":

    np.random.seed(19)

    # EXAMPLE 1
    T = 5 # number of observations to be made
    O = ("A", "B", "C", "D", "E") # observation space {o_i} for N possible observations generated from any state s_i
    S = (1, 2, 3, 4)  # state space {s_i} for K states

    N, K = len(O), len(S)

    Pi = np.random.rand(K) # probability vector {pi_i} for s_i being x_1 (first hidden state in path)
    Y = [] # observation sequence {y_i} generated by states S for the T observations made
        # {y_t} = i if the observation at time t is o_i
    A = np.random.rand(K,K) # transition matrix, A_ij = transition probability for s_i -> s_j
    B = np.random.rand(K,N) # emission matrix, B_ij = observation probability that state s_i generates o_j

    viterbi1 = Viterbi(O, S, Pi, A, B, T)

    '''
    # EXAMPLE 2 (Answer is X = H,H,F with probability = 0.01512)
    O = ("N","C","D")
    S = ("H","F")
    Pi = np.array([0.6,0.4])
    A = np.array([[0.7,0.3],[0.4,0.6]])
    B = np.array([[0.5,0.4,0.1],[0.1,0.3,0.6]])
    Y = ["N","C","D"]
    T = len(Y)
    
    viterbi1 = Viterbi(O, S, Pi, A, B, T, Y)
    '''


    X, prob = viterbi1.get_viterbi_path()
    print "\nViterbi path:\n\n", X
    print "Probability of this path:", prob
